"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var Utils = _interopRequireWildcard(require("../utils"));

var _ValueType = _interopRequireDefault(require("../ValueType"));

var _nodes = require("../nodes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EvaluatorBase =
/*#__PURE__*/
function () {
  function EvaluatorBase($type) {
    _classCallCheck(this, EvaluatorBase);

    if (this.constructor === EvaluatorBase) {
      throw new Error("Can't instantiate abstract class");
    }

    this.$type = "evaluator.".concat($type);
  }

  _createClass(EvaluatorBase, [{
    key: "evalProgram",
    value: function evalProgram()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalStatement",
    value: function evalStatement()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalParentheses",
    value: function evalParentheses()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNumberLiteral",
    value: function evalNumberLiteral()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalPercent",
    value: function evalPercent()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalArrayLiteral",
    value: function evalArrayLiteral()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalArrayElement",
    value: function evalArrayElement()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorNameLiteral",
    value: function evalColorNameLiteral()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorHexLiteral",
    value: function evalColorHexLiteral()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorByNumber",
    value: function evalColorByNumber()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorByTemperature",
    value: function evalColorByTemperature()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorByWavelength",
    value: function evalColorByWavelength()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorBySpaceParams",
    value: function evalColorBySpaceParams()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalRandomColor",
    value: function evalRandomColor()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalScale",
    value: function evalScale()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalBezier",
    value: function evalBezier()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalCubehelix",
    value: function evalCubehelix()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalBrewerConst",
    value: function evalBrewerConst()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalParam",
    value: function evalParam(node) {
      var _this = this;

      var obj = node.obj.evaluate(this.core);
      var objType = Utils.getType(obj);
      var defs = [];

      switch (objType) {
        case _ValueType["default"].Color:
          defs = this._getColorParamDefs();
          break;

        case _ValueType["default"].ColorScale:
          defs = this._getColorScaleParamDefs(obj.name);
          break;
      }

      if (!defs.length && objType & _ValueType["default"].Array) {
        defs.push({
          re: /^\d+$/i,
          get: function get(node) {
            return _this.evalArrayElement(node);
          }
        });
      }

      var result = this._manageParam(node, defs);

      return result;
    }
  }, {
    key: "evalManageColorNumber",
    value: function evalManageColorNumber()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorTemperature",
    value: function evalManageColorTemperature()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorLuminance",
    value: function evalManageColorLuminance()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorAlpha",
    value: function evalManageColorAlpha()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompRgbR",
    value: function evalManageColorCompRgbR()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompRgbG",
    value: function evalManageColorCompRgbG()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompRgbB",
    value: function evalManageColorCompRgbB()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompCmykC",
    value: function evalManageColorCompCmykC()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompCmykM",
    value: function evalManageColorCompCmykM()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompCmykY",
    value: function evalManageColorCompCmykY()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompCmykK",
    value: function evalManageColorCompCmykK()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHslH",
    value: function evalManageColorCompHslH()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHslS",
    value: function evalManageColorCompHslS()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHslL",
    value: function evalManageColorCompHslL()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsvH",
    value: function evalManageColorCompHsvH()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsvS",
    value: function evalManageColorCompHsvS()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsvV",
    value: function evalManageColorCompHsvV()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsiH",
    value: function evalManageColorCompHsiH()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsiS",
    value: function evalManageColorCompHsiS()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompHsiI",
    value: function evalManageColorCompHsiI()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLabL",
    value: function evalManageColorCompLabL()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLabA",
    value: function evalManageColorCompLabA()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLabB",
    value: function evalManageColorCompLabB()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLchL",
    value: function evalManageColorCompLchL()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLchC",
    value: function evalManageColorCompLchC()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalManageColorCompLchH",
    value: function evalManageColorCompLchH()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetColorScalePadding",
    value: function evalSetColorScalePadding()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetScaleDomain",
    value: function evalSetScaleDomain()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetCubehelixStart",
    value: function evalSetCubehelixStart()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetCubehelixRotations",
    value: function evalSetCubehelixRotations()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetCubehelixHue",
    value: function evalSetCubehelixHue()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetCubehelixGamma",
    value: function evalSetCubehelixGamma()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetCubehelixLightness",
    value: function evalSetCubehelixLightness()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalUnaryOperation",
    value: function evalUnaryOperation(node) {
      switch (node.operator) {
        case '-':
          return this.evalUnaryMinus(node);

        case '~':
          return this.evalColorInverse(node);

        case '+':
          return this.evalCorrectLightness(node);

        default:
          throw "invalid operator: ".concat(node.operator);
      }
    }
  }, {
    key: "evalUnaryMinus",
    value: function evalUnaryMinus()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorInverse",
    value: function evalColorInverse()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalCorrectLightness",
    value: function evalCorrectLightness()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalBinaryOperation",
    value: function evalBinaryOperation(node) {
      var left = node.left.evaluate(this.core);
      var right = node.right.evaluate(this.core);
      var isNumbers = [left, right].every(function (v) {
        return Utils.getType(v) === _ValueType["default"].Number;
      });
      var isColors = [left, right].every(function (v) {
        return Utils.getType(v) === _ValueType["default"].Color;
      });

      var isColorAndNumber = Utils.getType(left) === _ValueType["default"].Color && Utils.getType(right) === _ValueType["default"].Number;

      var isNumberAndColor = Utils.getType(left) === _ValueType["default"].Number && Utils.getType(right) === _ValueType["default"].Color;

      switch (node.operator) {
        case '+':
          if (isNumbers) {
            return this.evalNumbersAddition(node);
          } else if (isColors) {
            return this.evalAddBlend(node);
          } else if (isColorAndNumber || isNumberAndColor) {
            return this.evalColorAndNumberAddition(node);
          } else {
            break;
          }

        case '-':
          if (isNumbers) {
            return this.evalNumbersSubtraction(node);
          } else if (isColors) {
            return this.evalSubtractBlend(node);
          } else if (isColorAndNumber) {
            return this.evalColorAndNumberSubtraction(node);
          } else {
            break;
          }

        case '*':
          if (isNumbers) {
            return this.evalNumbersMultiplication(node);
          } else if (isColors) {
            return this.evalMultiplyBlend(node);
          } else if (isColorAndNumber || isNumberAndColor) {
            return this.evalColorAndNumberMultiplication(node);
          } else {
            break;
          }

        case '/':
          if (isNumbers) {
            return this.evalNumbersDivision(node);
          } else if (isColors) {
            return this.evalDivideBlend(node);
          } else if (isColorAndNumber) {
            return this.evalColorAndNumberDivision(node);
          } else {
            break;
          }

        case '^':
          if (isNumbers) {
            return this.evalNumberPower(node);
          } else {
            break;
          }

        case '%%':
          if (isColors) {
            return this.evalColorsContrast(node);
          } else {
            break;
          }

        case '|':
          if (isColors) {
            return this.evalColorsMix(node);
          } else {
            break;
          }

        case '->':
          if (Utils.getType(left) === _ValueType["default"].ColorScale && Utils.getType(right) === _ValueType["default"].Number) {
            return this.evalColorsFromScaleProduction(node);
          } else {
            break;
          }

        case '<<':
          if (isColorAndNumber) {
            return this.evalColorDesaturate(node);
          } else if (isColors) {
            return this.evalColorBurnBlend(node);
          } else {
            break;
          }

        case '>>':
          if (isColorAndNumber) {
            return this.evalColorSaturate(node);
          } else if (isColors) {
            return this.evalColorDodgeBlend(node);
          } else {
            break;
          }

        case '<<<':
          if (isColorAndNumber) {
            return this.evalColorDarken(node);
          } else if (isColors) {
            return this.evalDarkenBlend(node);
          } else {
            break;
          }

        case '>>>':
          if (isColorAndNumber) {
            return this.evalColorLighten(node);
          } else if (isColors) {
            return this.evalLightenBlend(node);
          } else {
            break;
          }

        case '!*':
          if (isColors) {
            return this.evalScreenBlend(node);
          } else {
            break;
          }

        case '**':
          if (isColors) {
            return this.evalOverlayBlend(node);
          } else {
            break;
          }

        case '<*':
          if (isColors) {
            return this.evalHardLightBlend(node);
          } else {
            break;
          }

        case '*>':
          if (isColors) {
            return this.evalSoftLightBlend(node);
          } else {
            break;
          }

        case '^*':
          if (isColors) {
            return this.evalDifferenceBlend(node);
          } else {
            break;
          }

        case '^^':
          if (isColors) {
            return this.evalExclusionBlend(node);
          } else {
            break;
          }

        case '!^':
          if (isColors) {
            return this.evalNegateBlend(node);
          } else {
            break;
          }

        default:
          Utils.throwError("invalid operator '".concat(node.operator, "'"));
      }

      Utils.throwError("".concat(Utils.getObjKey(_ValueType["default"], Utils.getType(left)), " ") + "and ".concat(Utils.getObjKey(_ValueType["default"], Utils.getType(right)), " ") + "is invalid operand types or sequence for operator '".concat(node.operator, "'"), node.$loc);
    }
  }, {
    key: "evalNumbersAddition",
    value: function evalNumbersAddition()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNumbersSubtraction",
    value: function evalNumbersSubtraction()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNumbersMultiplication",
    value: function evalNumbersMultiplication()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNumbersDivision",
    value: function evalNumbersDivision()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorAndNumberAddition",
    value: function evalColorAndNumberAddition()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorAndNumberSubtraction",
    value: function evalColorAndNumberSubtraction()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorAndNumberMultiplication",
    value: function evalColorAndNumberMultiplication()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorAndNumberDivision",
    value: function evalColorAndNumberDivision()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNumberPower",
    value: function evalNumberPower()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorsContrast",
    value: function evalColorsContrast()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorsMix",
    value: function evalColorsMix()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorsFromScaleProduction",
    value: function evalColorsFromScaleProduction()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorDesaturate",
    value: function evalColorDesaturate()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorSaturate",
    value: function evalColorSaturate()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorDarken",
    value: function evalColorDarken()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorLighten",
    value: function evalColorLighten()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalAddBlend",
    value: function evalAddBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSubtractBlend",
    value: function evalSubtractBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalMultiplyBlend",
    value: function evalMultiplyBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalDivideBlend",
    value: function evalDivideBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorBurnBlend",
    value: function evalColorBurnBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalColorDodgeBlend",
    value: function evalColorDodgeBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalDarkenBlend",
    value: function evalDarkenBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalLightenBlend",
    value: function evalLightenBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalScreenBlend",
    value: function evalScreenBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalOverlayBlend",
    value: function evalOverlayBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalHardLightBlend",
    value: function evalHardLightBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSoftLightBlend",
    value: function evalSoftLightBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalDifferenceBlend",
    value: function evalDifferenceBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalExclusionBlend",
    value: function evalExclusionBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalNegateBlend",
    value: function evalNegateBlend()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalGetVar",
    value: function evalGetVar()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "evalSetVar",
    value: function evalSetVar()
    /*node*/
    {
      notImpl();
    }
  }, {
    key: "_getNumberArithmeticFunc",
    value: function _getNumberArithmeticFunc(operator) {
      if (!['+', '-', '*', '/'].includes(operator)) {
        Utils.throwError("invalid arithmetic operator provided: '".concat(operator, "'"));
      }

      return eval("(function(a, b) { return a ".concat(operator, " b; })"));
    }
  }, {
    key: "_manageParam",
    value: function _manageParam(node, defs) {
      var opName = function () {
        if (node.value === void 0) {
          return 'get';
        } else if (!node.operator) {
          return 'set';
        } else {
          return 'relative set';
        }
      }();

      for (var i = 0; i < defs.length; i++) {
        var def = defs[i];

        if (node.name.match(def.re)) {
          var method = def.manage;

          if (!method) {
            method = node.value === void 0 ? def.get : def.set;

            if (node.operator) {
              method = def.setRel;
            }
          }

          if (method) {
            var result = method.call(def, node);

            if (result === void 0) {
              Utils.throwError("operation '".concat(opName, "' for parameter '").concat(node.name, "' is not supported by '").concat(this.$type, "'"), node.$loc);
            }

            return result;
          } else {
            Utils.throwError("operation '".concat(opName, "' is not supported for parameter '").concat(node.name, "'"), node.$loc);
          }

          break;
        }
      }

      Utils.throwError("unknown parameter name '".concat(node.name, "'"), node.$loc);
    }
  }, {
    key: "_getColorParamDefs",
    value: function _getColorParamDefs() {
      var _this2 = this;

      return [{
        re: /^(number|num|n)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorNumber(node);
        }
      }, {
        re: /^(temperature|temp|t)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorTemperature(node);
        }
      }, {
        re: /^((rgb|cmyk|hsl|hsv|hsi|lab|lch|hcl)\.)?(luminance|lum)$/i,
        manage: function manage(node) {
          if (node.value === void 0 && node.name.match(/\./)) {
            Utils.throwError('color space should not be specified when retrieving luminance', node.$loc);
          }

          return _this2.evalManageColorLuminance(node);
        }
      }, {
        re: /^(alpha|a)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorAlpha(node);
        }
      }, {
        re: /^(rgb\.)?(red|r)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompRgbR(node);
        }
      }, {
        re: /^(rgb\.)?(green|g)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompRgbG(node);
        }
      }, {
        re: /^(rgb\.)?(blue|b)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompRgbB(node);
        }
      }, {
        re: /^(cmyk\.)?(cyan|c)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompCmykC(node);
        }
      }, {
        re: /^(cmyk\.)?(magenta|mag|m)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompCmykM(node);
        }
      }, {
        re: /^(cmyk\.)?(yellow|yel|y)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompCmykY(node);
        }
      }, {
        re: /^(cmyk\.)?(key|k)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompCmykK(node);
        }
      }, {
        re: /^((hsl|hsv|hsi|lch|hcl)\.)?(hue|h)$/i,
        manage: function manage(node) {
          return node.name.match(/hsv/i) ? _this2.evalManageColorCompHsvH(node) : node.name.match(/hsi/i) ? _this2.evalManageColorCompHsiH(node) : node.name.match(/lch|hcl/i) ? _this2.evalManageColorCompLchH(node) : _this2.evalManageColorCompHslH(node);
        }
      }, {
        re: /^((hsl|hsv|hsi)\.)?(saturation|sat|s)$/i,
        manage: function manage(node) {
          return node.name.match(/hsv/i) ? _this2.evalManageColorCompHsvS(node) : node.name.match(/hsi/i) ? _this2.evalManageColorCompHsiS(node) : _this2.evalManageColorCompHslS(node);
        }
      }, {
        re: /^((hsl|lab|lch|hcl)\.)?(lightness|ltns|lt|l)$/i,
        manage: function manage(node) {
          return node.name.match(/lab/i) ? _this2.evalManageColorCompLabL(node) : node.name.match(/lch|hcl/i) ? _this2.evalManageColorCompLchL(node) : _this2.evalManageColorCompHslL(node);
        }
      }, {
        re: /^(hsv\.)?(value|val|v)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompHsvV(node);
        }
      }, {
        re: /^(hsi\.)?(intensity|int|i)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompHsiI(node);
        }
      }, {
        re: /^lab\.a$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompLabA(node);
        }
      }, {
        re: /^lab\.b$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompLabB(node);
        }
      }, {
        re: /^((((lch|hcl)\.)?(chroma|chr|ch))|lch\.c|hcl\.c)$/i,
        manage: function manage(node) {
          return _this2.evalManageColorCompLchC(node);
        }
      }];
    }
  }, {
    key: "_getColorScaleParamDefs",
    value: function _getColorScaleParamDefs(scaleName) {
      var _this3 = this;

      var defs = [{
        re: /^(padding|pad|p)$/i,
        set: function set(node) {
          return _this3.evalSetColorScalePadding(node);
        }
      }];

      if (scaleName === 'scale') {
        defs.push.apply(defs, [{
          re: /^(domain|dom|d)$/i,
          set: function set(node) {
            return _this3.evalSetScaleDomain(node);
          }
        }]);
      }

      if (scaleName === 'cubehelix') {
        defs.push.apply(defs, [{
          re: /^(start|s)$/i,
          set: function set(node) {
            return _this3.evalSetCubehelixStart(node);
          }
        }, {
          re: /^(rotations|rot|r)$/i,
          set: function set(node) {
            return _this3.evalSetCubehelixRotations(node);
          }
        }, {
          re: /^(hue|h)$/i,
          set: function set(node) {
            return _this3.evalSetCubehelixHue(node);
          }
        }, {
          re: /^(gamma|g)$/i,
          set: function set(node) {
            return _this3.evalSetCubehelixGamma(node);
          }
        }, {
          re: /^(lightness|lt|l)$/i,
          set: function set(node) {
            return _this3.evalSetCubehelixLightness(node);
          }
        }]);
      }

      return defs;
    }
  }, {
    key: "_unwrapParens",
    value: function _unwrapParens(node) {
      while (node instanceof _nodes.ParenthesesExpr) {
        node = node.expr;
      }

      return node;
    }
  }, {
    key: "core",
    get: function get() {
      throw new Error('Core evaluator should be returned in a derived class');
    }
  }]);

  return EvaluatorBase;
}();

exports["default"] = EvaluatorBase;

function notImpl() {
  throw new Error('Not implemented');
}